<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    Redis | 
</title>
<link rel="shortcut icon" href="https://daffupman.github.io/favicon.ico?v=1634906345588">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://daffupman.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://daffupman.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
            
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
                

                    
                            
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://daffupman.github.io">
                <img class="avatar" src="https://daffupman.github.io/images/avatar.png?v=1634906345588" alt="">
            </a>
            <div class="site-title">
                <h1>
                    
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            Redis
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-11-10</time>
                            
                                <a href="https://daffupman.github.io/odW_eMmv5/" class="post-tag i-tag
                            i-tag-other_3">
                            #redis
                        </a>
                                
                        </div>
                        
                            <div class="post-feature-image" style="background-image: url('https://for-markdown.oss-cn-shanghai.aliyuncs.com/1_77Vo1RFQ-5DcLKdeHbb2-A.png')"></div>
                            
                                <div class="post-content">
                                    <h2 id="nosql数据库">NoSQL数据库</h2>
<p>NoSQL,即Not only SQL，不仅仅是SQL，泛指非关系型数据库。NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大地增加了数据库的扩展能力。NoSQL不遵循SQL标准，不支持ACID，当有着远超SQL的性能。</p>
<p>适用的场景有：对数据高并发的读写、海量数据的读写、对数据高扩展性的以及用不着sql的和用了sql也不行的情况。但不适用于需要事务支持，也不可用于基于sql的存储和查询。</p>
<h2 id="redis">Redis</h2>
<p>Redis是一个开源的key-value存储系统。Redis支持各种数据结构，包括string、list、set、zset和hash。这些数据类型都支持push/pop、add/remove及取交集并集和差集等丰富的操作，且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。为保证效率，Redis的数据都缓存在内存中，同时也会周期性地把数据写入磁盘或把修改操作写入记录文件，在此基础上实现master-slave同步。</p>
<p>Redis是单线程+IO多路复用技术。多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行。</p>
<h3 id="安装">安装</h3>
<ol>
<li>下载地址：https://download.redis.io/releases/redis-5.0.5.tar.gz</li>
<li>在/opt目录下解压缩<pre><code class="language-bash">tar -zxvf redis-5.0.5.tar.gz
</code></pre>
</li>
<li>安装gcc环境<pre><code class="language-bash">yum -y install gcc-c++
</code></pre>
</li>
<li>在redis目录下编译运行<pre><code class="language-bash">make &amp;&amp; make install
</code></pre>
</li>
<li>配置文件到/etc/redis/下<pre><code class="language-bash">cp /opt/redis-5.0.5/redis.conf /etc/redis/
</code></pre>
</li>
<li>修改配置文件<pre><code class="language-bash">vim /etc/redis/redis.conf
</code></pre>
<blockquote>
<p>#修改daemonize为yes，后台运行<br>
daemonize yes<br>
#所有机器可连接<br>
bind 0.0.0.0<br>
#注释掉保护模式<br>
#protected-mode yes<br>
#设置登录密码<br>
requirepass root<br>
#设置工作目录<br>
dir /usr/local/redis</p>
</blockquote>
</li>
<li>开机自启
<ol>
<li>拷贝启动脚本到 <code>/etc/init.d</code> 下<pre><code class="language-bash">cp /opt/redis-5.0.5/utils/redis_init_script /etc/init.d
</code></pre>
</li>
<li>编辑脚本文件<pre><code class="language-bash">vim /etc/init.d/redis_init_script
</code></pre>
<blockquote>
<p>########### 第二行添加以下文字 ############<br>
#chkconfig: 22345 10 90<br>
#description: start redis at boot time<br>
#修改CONF属性值为redis自定义的配置<br>
CONF=&quot;/etc/redis/redis.conf&quot;</p>
</blockquote>
</li>
<li>加入系统自启<pre><code class="language-bash">chkconfig --add redis_init_script
</code></pre>
</li>
<li>开启脚本<pre><code class="language-bash">chkconfig redis_init_script on
</code></pre>
</li>
</ol>
</li>
<li>重启redis<pre><code class="language-bash">./etc/init.d/redis_init_script start
</code></pre>
</li>
</ol>
<h3 id="redis五大数据类型">Redis五大数据类型</h3>
<h4 id="string类型">String类型</h4>
<p>String是最基本的类型，采用key-value形式。String类型使二进制安全的，redis的String可以包含任何数据，如图片或序列化对象。一个Redis中字符串value最多可以是512M。使用示例：</p>
<blockquote>
<p>get <key>				# 查询对应的键值<br>
set <key> <value>		# 添加键值对<br>
append <key> <value>	# 将给定的value追加到原值的末尾<br>
strlen <key>			# 获得值得长度<br>
setnx <key> <value>		# key不存在时设置key<br>
incr <key>				# key值加一，如果key为null，key则为1<br>
decr <key>				# key值建议，如果key为null，key则为-1<br>
incrby/decrby <key> &lt;步长&gt;	#key值按指定步长变化<br>
mset <key1> <val1> <key2> <val2> ...# 同时设置一个或多个key-val对<br>
mget <key1> <val1> <key2> <val2> ...# 同时获取一个或多个value<br>
msetnx <key1> <val1> <key2> <val2>	# 同时设置一个或多个key-val对，当且仅当key都不存在<br>
getrange <key> <start> <end>	# 获得值得范围<br>
setrange <keu> <start> <value>	# 从start位置开始，用val覆写key所存储的值<br>
setex <key> <time> <value>		# 设置key-val，同时加上过期时间<br>
getset <key> <val>				# 设置新值，返回旧值</p>
</blockquote>
<h4 id="list类型">List类型</h4>
<p>单值多键。Redis列表是简单的字符串列表，按照插入顺序排序。key从列表的头部（左边）或尾部（右边）插入。List底层是双向链表，两端操作性能很高，中间的节点相对较差。</p>
<blockquote>
<p>lpush/rpush <key> <val1> <val2>...   # 从左边/右边插入一个或多个值<br>
lpop/rpop <key>  # 从左边/右边吐出一个值，值在键在，值光键亡<br>
rpoplpush <key1> <key2>  # 从key1列表右边吐出一个值，从左边插入&gt; key2<br>
lrange <key> <start> <stop>  # 按照索引下标获得元素（从左到右）<br>
lindex <key> <index>  # 按照索引下标获得元素（从左到右）<br>
llen <key>  # 获得列表长度<br>
linsert <key> before <val> <newVal>	 # 在val后面插入newValue<br>
lrem <key> <n> <val>	 # 从左边删除n个val</p>
</blockquote>
<h4 id="set类型">Set类型</h4>
<p>set可以自动去重，并判断某个成员是否在一个set集合类。set是String类型的无序集合，底层为一个value为null的hash表，所以删除、查找的复杂度都是O(1)。</p>
<blockquote>
<p>sadd <key> <val1> <val2>...			# 将多个元素放入到key集合中，相同的则忽略<br>
smembers <key>						# 取出该集合的所有值<br>
sismember <key> <val>				# 判断key集合是否有val值，有返1，无返0<br>
scard <key>							# 返回该集合的元素个数<br>
srem <key> <val1> <val2>			# 删除集合种的元素<br>
spop <key>							# 随机吐出一个值<br>
srandmember <key> <n>				# 随机从key集合中取出n个值，不会删除<br>
sint <key1> <key2>					# 返回两个集合的交集元素<br>
sunion <key1> <key2>				# 返回两个集合的并集元素<br>
sdiff <key1> <key2>					# 返回两个集合的差集元素</p>
</blockquote>
<h4 id="hash类型">Hash类型</h4>
<p>Hash是一个string类型的field和value的映射表，HashMap适合用于存储对象。使用示例：</p>
<blockquote>
<p>hset <key> <field> <value>		# 给key集合中的field键赋值value<br>
hget <key1> <field>				# 从key1集合field取出value<br>
hmset <key1> <field1> <val1> <field2> <val2>	# 批量设置hash的值<br>
hexists key <field>				# 查看hash表key中，给定field是否存在<br>
hkeys <key>						# 列出该hash集合的所有field<br>
hvals <key>						# 列出该hash集合的所有value<br>
hincrby <key> <field> <increment>	# 为hash表key中的域field的值加上increment<br>
hsetnx <key> <field> <value>	# 当field不存在时，将key中的field值设置为value</p>
</blockquote>
<h4 id="zset类型">zset类型</h4>
<p>zset是一个没有重复元素的字符串集合。与set集合不同的是，有序集合的每个成员都关联了一个评分，这个评分score被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。</p>
<p>因为元素是有序的，可以很快的根据评分或次序来获取一个范围的元素。访问有序集合的中间元素也很快。</p>
<p>使用示例：</p>
<blockquote>
<p>zadd <key> <score1> <val1> <score2> <val2>...	# 将一个或多个元素及其score值加入到有序集key中<br>
zrang <key> <start> <stop> [withscores]			# 返回有序集key中，下标在<start>和<stop>之间的元素（含scores）<br>
zrangebyscore key min max [withscores] [limit offset count]	# 返回有序集key中，所有score值介于min和max之间（包含）的成员，有序集成员按score值递增排列<br>
zrevrangebyscore key max min [withscores] [limit offset count]	# 同上，逆序<br>
zincrby <key> <incrment> <val>	# 为元素的score加上增量<br>
zrem <key> <val>	# 删除该集合下指定值得元素<br>
zcount <key> <min> <max>	#统计该集合，分数区间内的元素个数<br>
zrank <key> <val>	# 返回该值在集合中的排名（基于0）</p>
</blockquote>
<h2 id="redis事务">Redis事务</h2>
<p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<h3 id="特性">特性</h3>
<ol>
<li>单独的隔离操作</li>
<li>没有隔离级别概念</li>
<li>不保证原子性</li>
</ol>
<h3 id="指令">指令</h3>
<ul>
<li>multi：开启multi后，之后的命令入队，但不会执行；</li>
<li>exec：执行入队的命令；</li>
<li>discard：在入队的过程中可以使用discard放弃组队正常的事务执行流程。<br>
当组队阶段中某个命令出现了错误，在exec时整个队列都会被取消。如果执行阶段某个命令报错，只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</li>
</ul>
<h3 id="事务的冲突和解决方式">事务的冲突和解决方式</h3>
<p>事务中可能存在的多个指令同时修改某个共享资源，但实际上有限的共享资源是不足以满足那些所有的指令的。这时候就是一个事务冲突的现象。一般可以借助悲观锁或乐观锁的思想解决。</p>
<h4 id="悲观锁pessimistic-lock">悲观锁（Pessimistic Lock）</h4>
<p>悲观锁认为每次对数据的操作都是会修改的，所有每次都会加上锁。在传统的关系型数据库中用的很多，比如：行锁、表锁、读锁、写锁等。</p>
<h4 id="乐观锁optimistic-lock">乐观锁（Optimistic Lock）</h4>
<p>与悲观锁相反，乐观锁认为每次对数据的操作都不会修改，所以并不会上锁，但会在数据更新的时候同时判断此期间原来的数据有没有被修改，一般使用版本号机制（check-and-set）。</p>
<p>在redis也有应用乐观锁的相应的指令：watch。在执行multi指令之前，先使用watch命令监视一个或多个key。</p>
<pre><code class="language-bash">watch k1 [k2, ...]
</code></pre>
<p>在事务执行（exec）之前，只要这些被监视的key有所改动，那么事务将被打断。也可使用unwatch取消对key的监视。</p>
<h2 id="redis的持久化">Redis的持久化</h2>
<p>redis是一种内存数据库，但也提供了持久化的技术。主要有RDB和AOF。</p>
<h3 id="rdbredis-database">RDB（Redis Database）</h3>
<p>在指定的时间内将内存中的数据集快照（snapshot）写入磁盘，恢复时将快照文件读入内存。</p>
<p>RDB的过程大致是这样的：Redis会单独创建（fork）一个子进程做持久化。子进程先将数据写入到一个临时文件中，待持久化结束后，再用这个临时文件替换上一次持久化好的文件。整个过程中，主进程不进行任何IO操作，确保了极高的性能。如果需要大规模数据的恢复，且对于数据的恢复的完整性不高，那RDB会比AOF更高效，但缺点就是丢失最后一次持久化的数据。</p>
<blockquote>
<p>关于fork：<br>
在linux系统中，调用fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调&gt; 用。出于效率考虑，Linux中引入“写时复制”技术，一般情况父进程和子进程会共用一段物理内存，只有&gt; 进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
</blockquote>
<h4 id="配置文件相关的配置项">配置文件相关的配置项</h4>
<blockquote>
<p>#db保存的文件名称<br>
dbfilename dump.rdb<br>
#rdb文件的保存的路径<br>
dir ./<br>
#rdb的保存策略<br>
save 900 1<br>
save 300 10<br>
save 60 10000<br>
#当redis无法写入磁盘的话，直接关闭redis的写操作。可能造成数据不一致<br>
stop-writes-on-bgsave-error yes<br>
#进行RDB保存时将文件压缩，会消耗一些cpu的资源<br>
rdbcompression yes<br>
#关闭rdb存储数据时的数据校验，可提升性能，开启的话会有10%的性能损耗<br>
rdbchecksum no</p>
</blockquote>
<h4 id="备份与恢复">备份与恢复</h4>
<h5 id="备份">备份</h5>
<pre><code class="language-bash">config get dir	# 查询RDB文件的路径
cp *.rdb /target	# 复制备份文件到其他目录
</code></pre>
<h5 id="恢复">恢复</h5>
<pre><code class="language-bash">cp /target/* /redis	# 将备份的文件复制到dir下，redis启动时会自动加载
</code></pre>
<h4 id="rdb的优点和缺点">RDB的优点和缺点</h4>
<ul>
<li>优点
<ul>
<li>每隔一段时间全量备份数据</li>
<li>灾备简单，可远程传输</li>
<li>子进程备份的时候，主进程不会有任何io，保证数据的完整性</li>
<li>相对于aof，可以快速重启恢复大文件</li>
</ul>
</li>
<li>缺点
<ul>
<li>相对于aof，可以快速重启恢复大文件</li>
<li>子进程会和父进程占用的大小一样的内存，cpu压力大</li>
<li>不能实时备份</li>
</ul>
</li>
</ul>
<h3 id="aofappend-of-file">AOF（Append Of File）</h3>
<p>以日志的形式来记录每个写操作。将redis执行的每一个写指令（读指令不管）记录在文件里，该文件只能追加，不能更改。redis在启动之初，会读取日志文件，重新执行所有的命令。AOF默认不开启，需要修改配置文件。</p>
<blockquote>
<p>#开启aof<br>
appendonly yes<br>
#指定aof文件，路径与rdb一致<br>
appendfilename &quot;appendfileonly.aof&quot;</p>
</blockquote>
<p>apf的备份与恢复与rdb一样。当同时开启aof和rdb，系统默认读取aof的数据。如果aof文件损害，使用以下命令恢复：<code>redis-check-aof --fix appendonly.aof</code>。</p>
<h4 id="aof的配置">aof的配置</h4>
<blockquote>
<p>#appendfsync always<br>
appendfsync everysec	# 不确定则使用这个，每秒进行一次备份<br>
#appendfsync no</p>
<p>#重写的时候是否要同步，no可以保证数据安全<br>
no-appendfsync-on-rewrite no</p>
<p>#重写机制：避免文件越来越大，自动优化压缩指令，会fork一个新的进程去完成重写动作，新进程里的内存数据会被重写，此时旧的aof文件不会被读取使用，类似rdb<br>
#当前AOF文件的大小是上次AOF大小的100% 并且文件体积达到64m，满足两者则触发重写<br>
auto-aof-rewrite-percentage 100<br>
auto-aof-rewrite-min-size 64mb</p>
</blockquote>
<h4 id="aof的优点和缺点">aof的优点和缺点</h4>
<ul>
<li>优点：
<ul>
<li>aof操作可以增加数据的可靠性和完整性，还可以异步操作；</li>
<li>以日志的形式追加，在磁盘满的时候，会执行redis-check-aof；</li>
<li>数据大的时候，redis会自动重写aof，重写是安全的，不会影响到客户端的读写；</li>
</ul>
</li>
<li>缺点：
<ul>
<li>相同的数据，aof会比rdb占用的内存大；</li>
<li>aof的同步机制会不如rdb，aof每秒都做备份写数据，相对于rdb来说速度较慢。以fsync备份的话，可以提升速度，但也会影响cpu性能。</li>
</ul>
</li>
</ul>
<h3 id="rdb和aof选择问题">RDB和AOF选择问题</h3>
<p>RDB适合大量数据的恢复，但数据的完整性和一致性可能会不足。RDB可能会丢失最后一次的备份，作为缓存来说，是可以忍受的。但是缓存的数据是要保证数据的完整性，需要使用AOF。</p>
<ul>
<li>如果可以接受一段时间的缓存丢失，可以使用RDB</li>
<li>如果需要保证实时性的数据，使用AOF</li>
<li>RDB和AOF可以一起使用，RDB做冷备，可在不同时期对不同版本做备份，AOF做热备，数据可以只有1秒的丢失。当AOF不可用的使用，可以再用RDB恢复。也就是Redis的恢复会先加载AOF，如果AOF有问题，会加载RDB。</li>
<li>如果只做缓存，都不用</li>
</ul>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://daffupman.github.io/WZxqM5YDi/">
                                <h3 class="post-title">
                                    MySQL的索引及优化
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#nosql%E6%95%B0%E6%8D%AE%E5%BA%93">NoSQL数据库</a></li>
<li><a href="#redis">Redis</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Redis五大数据类型</a>
<ul>
<li><a href="#string%E7%B1%BB%E5%9E%8B">String类型</a></li>
<li><a href="#list%E7%B1%BB%E5%9E%8B">List类型</a></li>
<li><a href="#set%E7%B1%BB%E5%9E%8B">Set类型</a></li>
<li><a href="#hash%E7%B1%BB%E5%9E%8B">Hash类型</a></li>
<li><a href="#zset%E7%B1%BB%E5%9E%8B">zset类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis%E4%BA%8B%E5%8A%A1">Redis事务</a>
<ul>
<li><a href="#%E7%89%B9%E6%80%A7">特性</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4">指令</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%86%B2%E7%AA%81%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F">事务的冲突和解决方式</a>
<ul>
<li><a href="#%E6%82%B2%E8%A7%82%E9%94%81pessimistic-lock">悲观锁（Pessimistic Lock）</a></li>
<li><a href="#%E4%B9%90%E8%A7%82%E9%94%81optimistic-lock">乐观锁（Optimistic Lock）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96">Redis的持久化</a>
<ul>
<li><a href="#rdbredis-database">RDB（Redis Database）</a>
<ul>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9">配置文件相关的配置项</a></li>
<li><a href="#%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D">备份与恢复</a>
<ul>
<li><a href="#%E5%A4%87%E4%BB%BD">备份</a></li>
<li><a href="#%E6%81%A2%E5%A4%8D">恢复</a></li>
</ul>
</li>
<li><a href="#rdb%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">RDB的优点和缺点</a></li>
</ul>
</li>
<li><a href="#aofappend-of-file">AOF（Append Of File）</a>
<ul>
<li><a href="#aof%E7%9A%84%E9%85%8D%E7%BD%AE">aof的配置</a></li>
<li><a href="#aof%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">aof的优点和缺点</a></li>
</ul>
</li>
<li><a href="#rdb%E5%92%8Caof%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98">RDB和AOF选择问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
   | 
  <a class="rss" href="https://daffupman.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
        
            <script>
    window.onload = function() {
        var gitalk = new Gitalk({
            clientID: '9f58dbffcdaf89d24412',
            clientSecret: '1285bea2c70ba4c5d996b68cf847056d9b5b68fd',
            repo: 'daffupman.github.io',
            owner: 'daffupman',
            admin: ['daffupman'],
            id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50
            distractionFreeMode: false // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    }
</script>
                

                    
                                
</body>

</html>